<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probability Lab: List 2</title>
    
    <!-- MathJax Configuration & Loader -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            /* Dark Theme Palette - Consistent with List 1 */
            --primary: #3b82f6; 
            --primary-hover: #2563eb;
            --bg: #111827; 
            --card-bg: #1f2937; 
            --text: #f3f4f6; 
            --text-muted: #9ca3af;
            --border: #374151;
            --canvas-bg: #111827;
            --success: #10b981;
            --danger: #ef4444;
            --accent: #8b5cf6;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid var(--border);
        }

        header {
            background: #111827;
            border-bottom: 1px solid var(--border);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { margin: 0; font-size: 1.5rem; color: var(--text); }
        p.subtitle { margin: 5px 0 0; color: var(--text-muted); font-size: 0.9rem; }

        .lang-switch {
            display: flex;
            gap: 5px;
            background: var(--border);
            padding: 4px;
            border-radius: 6px;
        }
        
        .lang-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: bold;
        }

        .lang-btn.active { background: var(--primary); color: white; }

        .tabs {
            display: flex;
            background: #111827;
            border-bottom: 1px solid var(--border);
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-muted);
            transition: all 0.2s;
            border: none;
            background: none;
            border-bottom: 3px solid transparent;
        }

        .tab:hover { color: var(--text); background-color: rgba(255,255,255,0.05); }
        .tab.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
            background-color: var(--card-bg);
        }

        .section {
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s ease-in-out;
        }
        .section.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        button.action-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button.action-btn:hover { background-color: var(--primary-hover); }
        button.secondary { background-color: var(--border); color: var(--text); }
        button.secondary:hover { background-color: #4b5563; }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            position: relative;
        }

        canvas {
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--canvas-bg);
            max-width: 100%;
        }

        .description {
            margin-bottom: 20px;
            line-height: 1.6;
            color: var(--text);
            background: rgba(59, 130, 246, 0.1);
            padding: 15px;
            border-left: 4px solid var(--primary);
            border-radius: 4px;
        }

        /* Continuous specific inputs */
        .range-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
            color: var(--text-muted);
            margin-bottom: 10px;
        }
        input[type="number"] {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 5px;
            border-radius: 4px;
            width: 60px;
        }

        /* Stats grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .stat-box {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid var(--border);
        }
        .stat-val { font-size: 1.2rem; font-weight: bold; color: var(--primary); font-family: monospace; }
        .stat-lbl { font-size: 0.8rem; color: var(--text-muted); }

    </style>
</head>
<body>

<div class="container">
    <header>
        <div class="header-content">
            <h1 data-key="title">Random Variables Lab</h1>
            <p class="subtitle" data-key="subtitle">List 2: Discrete PMF/CDF, Continuous Density, and 2D Distributions</p>
        </div>
        <div class="lang-switch">
            <button class="lang-btn active" onclick="setLanguage('en')">EN</button>
            <button class="lang-btn" onclick="setLanguage('pl')">PL</button>
        </div>
    </header>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('discrete')" data-key="tabDiscrete">1. Discrete (PMF/CDF)</button>
        <button class="tab" onclick="switchTab('continuous')" data-key="tabContinuous">2. Continuous (Monte Carlo)</button>
        <button class="tab" onclick="switchTab('2d')" data-key="tab2d">3. 2D Variables</button>
    </div>

    <!-- SEKCJA 1: DYSKRETNA -->
    <div id="discrete" class="section active">
        <div class="description" data-key="descDiscrete">
            <strong>Problem:</strong> A random variable X takes values $\{-2, -1, 0, 1, 3\}$. We simulate drawing samples to see how the Probability Mass Function (histogram) and Cumulative Distribution Function (stairs) form empirically. (Tasks 1 & 2).
        </div>

        <div class="controls">
            <button class="action-btn" onclick="startDiscreteAnim()" data-key="btnSample">Sample (Anim)</button>
            <button class="action-btn" onclick="fastForwardDiscrete()" data-key="btnFast">Fast Forward (+1000)</button>
            <button class="action-btn secondary" onclick="resetDiscrete()" data-key="btnReset">Reset</button>
        </div>

        <div class="canvas-container">
            <!-- Canvas is taller to accommodate both PMF and CDF -->
            <canvas id="discreteCanvas" width="600" height="400"></canvas>
        </div>
    </div>

    <!-- SEKCJA 2: CIĄGŁA -->
    <div id="continuous" class="section">
        <div class="description" data-key="descContinuous">
            <strong>Problem:</strong> Density $f(x) = \frac{1}{9}x^2$ on $[0, 3]$. Probability is the area under the curve. We use Monte Carlo (random points) to estimate the probability in a range $(a, b)$. (Tasks 3 & 4).
        </div>

        <div class="controls">
            <div class="range-inputs">
                <span>Range:</span>
                <input type="number" id="rangeA" value="1.0" step="0.1" min="0" max="3">
                <span>&lt; X &lt;</span>
                <input type="number" id="rangeB" value="2.0" step="0.1" min="0" max="3">
            </div>
            <button class="action-btn" onclick="runMonteCarlo()" data-key="btnRunMC">Throw 1000 Points</button>
            <button class="action-btn secondary" onclick="resetMonteCarlo()" data-key="btnReset">Reset</button>
        </div>

        <div class="canvas-container">
            <canvas id="contCanvas" width="600" height="300"></canvas>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div id="mcTotal" class="stat-val">0</div>
                <div class="stat-lbl" data-key="statTotal">Total Points</div>
            </div>
            <div class="stat-box">
                <div id="mcHits" class="stat-val">0</div>
                <div class="stat-lbl" data-key="statHits">Points in Range</div>
            </div>
            <div class="stat-box">
                <div id="mcProb" class="stat-val">0.000</div>
                <div class="stat-lbl" data-key="statEstProb">Est. Probability</div>
            </div>
            <div class="stat-box">
                <div id="mcTheory" class="stat-val">0.000</div>
                <div class="stat-lbl" data-key="statTheoryProb">Theoretical Prob</div>
            </div>
        </div>
    </div>

    <!-- SEKCJA 3: 2D -->
    <div id="2d" class="section">
        <div class="description" data-key="desc2d">
            <strong>Problem:</strong> Joint distribution of $(X, Y)$ from Task 6. Visualize how the joint probability table collapses into Marginal Distributions (summing rows/cols) and how Conditional Distributions work (slicing a row).
        </div>

        <div class="controls">
            <button class="action-btn" onclick="set2DMode('joint')" data-key="btnJoint">Joint Dist.</button>
            <button class="action-btn" onclick="set2DMode('marginal')" data-key="btnMarginal">Show Marginals</button>
            <button class="action-btn" onclick="set2DMode('condX0')" data-key="btnCondX0">Condition P(Y|X=0)</button>
        </div>

        <div class="canvas-container">
            <canvas id="canvas2d" width="600" height="400"></canvas>
        </div>
    </div>

</div>

<script>
    // --- TRANSLATIONS ---
    const translations = {
        en: {
            title: "Random Variables Lab",
            subtitle: "List 2: Discrete PMF/CDF, Continuous Density, and 2D Distributions",
            tabDiscrete: "1. Discrete (PMF/CDF)",
            tabContinuous: "2. Continuous (Monte Carlo)",
            tab2d: "3. 2D Variables",
            descDiscrete: "<strong>Problem:</strong> A random variable X takes values $\\{-2, -1, 0, 1, 3\\}$. We simulate drawing samples to see how the Probability Mass Function (histogram) and Cumulative Distribution Function (stairs) form empirically. (Tasks 1 & 2).",
            btnSample: "Sample (Anim)",
            btnFast: "Fast Forward (+1000)",
            btnReset: "Reset",
            descContinuous: "<strong>Problem:</strong> Density $f(x) = \\frac{1}{9}x^2$ on $[0, 3]$. Probability is the area under the curve. We use Monte Carlo (random points) to estimate the probability in a range $(a, b)$. (Tasks 3 & 4).",
            btnRunMC: "Throw 1000 Points",
            statTotal: "Total Points",
            statHits: "Points in Range",
            statEstProb: "Est. Probability",
            statTheoryProb: "Theoretical Prob",
            desc2d: "<strong>Problem:</strong> Joint distribution of $(X, Y)$ from Task 6. Visualize how the joint probability table collapses into Marginal Distributions (summing rows/cols) and how Conditional Distributions work (slicing a row).",
            btnJoint: "Joint Dist.",
            btnMarginal: "Show Marginals (Anim)",
            btnCondX0: "Condition P(Y|X=0)",
            // Canvas Labels
            labelPMF: "Probability Mass Function (PMF)",
            labelCDF: "Cumulative Distribution Function (CDF)",
            labelDensity: "Density f(x) = x²/9",
            labelMarginalX: "Marginal X",
            labelMarginalY: "Marginal Y",
            labelJoint: "Joint P(X,Y)"
        },
        pl: {
            title: "Laboratorium Zmiennych Losowych",
            subtitle: "Lista 2: Rozkłady Dyskretne, Ciągłe i 2D",
            tabDiscrete: "1. Dyskretne (PMF/CDF)",
            tabContinuous: "2. Ciągłe (Monte Carlo)",
            tab2d: "3. Zmienne 2D",
            descDiscrete: "<strong>Zagadnienie:</strong> Zmienna losowa X przyjmuje wartości $\\{-2, -1, 0, 1, 3\\}$. Symulujemy losowanie próbek, aby zobaczyć jak empirycznie tworzy się Histogram (PMF) i Dystrybuanta (CDF). (Zadania 1 i 2).",
            btnSample: "Próbkuj (Anim)",
            btnFast: "Szybko (+1000)",
            btnReset: "Resetuj",
            descContinuous: "<strong>Zagadnienie:</strong> Gęstość $f(x) = \\frac{1}{9}x^2$ na $[0, 3]$. Prawdopodobieństwo to pole pod krzywą. Używamy Monte Carlo (losowe punkty) do estymacji p-stwa w przedziale $(a, b)$. (Zadania 3 i 4).",
            btnRunMC: "Rzuć 1000 Punktów",
            statTotal: "Wszystkie Punkty",
            statHits: "Punkty w Zakresie",
            statEstProb: "Estymowane P-stwo",
            statTheoryProb: "Teoretyczne P-stwo",
            desc2d: "<strong>Zagadnienie:</strong> Rozkład łączny $(X, Y)$ z Zadania 6. Wizualizacja jak tabela prawdopodobieństw składa się do Rozkładów Brzegowych (sumowanie) i jak działa P-stwo Warunkowe (wycinek wiersza).",
            btnJoint: "Rozkład Łączny",
            btnMarginal: "Rozkłady Brzegowe",
            btnCondX0: "Warunkowe P(Y|X=0)",
            // Canvas Labels
            labelPMF: "Funkcja Prawdopodobieństwa (PMF)",
            labelCDF: "Dystrybuanta (CDF)",
            labelDensity: "Gęstość f(x) = x²/9",
            labelMarginalX: "Brzegowy X",
            labelMarginalY: "Brzegowy Y",
            labelJoint: "Łączny P(X,Y)"
        }
    };

    let currentLang = 'en';
    function setLanguage(lang) {
        currentLang = lang;
        const t = translations[lang];
        document.querySelectorAll('[data-key]').forEach(el => {
            const key = el.getAttribute('data-key');
            if(t[key]) el.innerHTML = t[key];
        });
        document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtnIndex = lang === 'en' ? 0 : 1;
        document.querySelectorAll('.lang-btn')[activeBtnIndex].classList.add('active');

        // Trigger MathJax re-render
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise();
        }

        // Redraw current tab
        if(document.getElementById('discrete').classList.contains('active')) drawDiscrete();
        if(document.getElementById('continuous').classList.contains('active')) drawContinuous();
        if(document.getElementById('2d').classList.contains('active')) draw2D();
    }

    // --- TAB SWITCHING ---
    function switchTab(tabId) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        
        const tabs = ['discrete', 'continuous', '2d'];
        document.querySelectorAll('.tab')[tabs.indexOf(tabId)].classList.add('active');
        document.getElementById(tabId).classList.add('active');

        if(tabId === 'discrete') drawDiscrete();
        if(tabId === 'continuous') drawContinuous();
        if(tabId === '2d') draw2D();
    }

    // ==========================================
    // MODULE 1: DISCRETE (PMF & CDF)
    // ==========================================
    const discValues = [-2, -1, 0, 1, 3];
    const discProbs = [0.1, 0.3, 0.2, 0.3, 0.1]; // Calculated C=0.3
    // Cumulative probs for sampling: [0.1, 0.4, 0.6, 0.9, 1.0]
    let discCounts = [0, 0, 0, 0, 0];
    let discTotal = 0;
    let particles = []; // {x, y, targetIdx}

    function resetDiscrete() {
        discCounts = [0, 0, 0, 0, 0];
        discTotal = 0;
        particles = [];
        drawDiscrete();
    }

    function sampleDiscrete() {
        const r = Math.random();
        let sum = 0;
        for(let i=0; i<discProbs.length; i++) {
            sum += discProbs[i];
            if(r < sum) return i;
        }
        return discProbs.length - 1;
    }

    function startDiscreteAnim() {
        // Spawn a particle
        const idx = sampleDiscrete();
        // X position based on bins (canvas width 600, 5 bins, padding)
        // Bin width approx 80, centered
        const binW = 80;
        const startX = 100 + idx * binW + binW/2;
        particles.push({x: startX, y: 0, targetIdx: idx});
        
        if(particles.length === 1) requestAnimationFrame(animateDiscrete);
    }

    function fastForwardDiscrete() {
        for(let i=0; i<1000; i++) {
            discCounts[sampleDiscrete()]++;
            discTotal++;
        }
        drawDiscrete();
    }

    function animateDiscrete() {
        if(particles.length === 0) return;
        
        // Update physics
        for(let i=particles.length-1; i>=0; i--) {
            particles[i].y += 15; // Speed
            // Hit floor (split screen: top half is 200px)
            if(particles[i].y >= 180) {
                discCounts[particles[i].targetIdx]++;
                discTotal++;
                particles.splice(i, 1);
            }
        }
        
        drawDiscrete();
        if(particles.length > 0) requestAnimationFrame(animateDiscrete);
    }

    function drawDiscrete() {
        const canvas = document.getElementById('discreteCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const t = translations[currentLang];

        ctx.clearRect(0,0,w,h);

        // --- TOP: PMF (Histogram) ---
        const topH = h/2 - 20;
        const binW = 80;
        const offsetX = 100;

        ctx.strokeStyle = "#4b5563";
        ctx.beginPath(); ctx.moveTo(50, topH); ctx.lineTo(w-50, topH); ctx.stroke(); // X axis

        // Label PMF
        ctx.fillStyle = "#9ca3af"; ctx.font = "12px sans-serif";
        ctx.fillText(t.labelPMF, 10, 20);

        // Max theoretical prob is 0.3. Let's scale max height to 0.5 for headroom
        const scaleY = topH / 0.5; 

        discValues.forEach((val, i) => {
            const cx = offsetX + i * binW + binW/2;
            
            // Draw theoretical (outline)
            const thH = discProbs[i] * scaleY;
            ctx.strokeStyle = "rgba(59, 130, 246, 0.3)";
            ctx.strokeRect(offsetX + i*binW + 10, topH - thH, binW - 20, thH);

            // Draw empirical (fill)
            if(discTotal > 0) {
                const empProb = discCounts[i] / discTotal;
                const empH = empProb * scaleY;
                ctx.fillStyle = "#3b82f6";
                ctx.fillRect(offsetX + i*binW + 10, topH - empH, binW - 20, empH);
                
                // Text stats
                ctx.fillStyle = "#fff";
                ctx.textAlign = "center";
                ctx.fillText(empProb.toFixed(2), cx, topH - empH - 5);
            }

            // X Labels
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.fillText(val, cx, topH + 15);
        });

        // Draw falling particles
        ctx.fillStyle = "#f59e0b";
        particles.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
        });

        // --- BOTTOM: CDF (Stairs) ---
        const botY = h - 30;
        const botTop = h/2 + 30;
        const graphH = botY - botTop;

        // Label CDF
        ctx.fillStyle = "#9ca3af"; ctx.textAlign = "left";
        ctx.fillText(t.labelCDF, 10, botTop - 10);
        
        // Axis
        ctx.strokeStyle = "#4b5563";
        ctx.beginPath(); ctx.moveTo(50, botY); ctx.lineTo(w-50, botY); ctx.stroke(); // X
        ctx.beginPath(); ctx.moveTo(offsetX, botY); ctx.lineTo(offsetX, botTop); ctx.stroke(); // Y (at x=-3 approx)

        // Draw 1.0 line
        ctx.setLineDash([5,5]); ctx.strokeStyle = "#374151";
        ctx.beginPath(); ctx.moveTo(50, botTop); ctx.lineTo(w-50, botTop); ctx.stroke();
        ctx.setLineDash([]);

        // Calculate CDF points
        let cumProp = 0;
        const empiricalCDF = discValues.map((_, i) => {
            if(discTotal === 0) return 0;
            cumProp += discCounts[i] / discTotal;
            return cumProp;
        });

        // Draw Steps
        ctx.strokeStyle = "#10b981";
        ctx.lineWidth = 2;
        let prevX = 50;
        let prevY = botY;

        discValues.forEach((val, i) => {
            const cx = offsetX + i * binW + binW/2; // Center of bin as "value point"
            const cy = botY - (empiricalCDF[i] * graphH);

            // Horizontal line from prevX to current value
            ctx.beginPath(); ctx.moveTo(prevX, prevY); ctx.lineTo(cx, prevY); ctx.stroke();
            
            // Vertical jump
            ctx.beginPath(); ctx.moveTo(cx, prevY); ctx.lineTo(cx, cy); ctx.stroke();

            // Point
            ctx.fillStyle = "#10b981";
            ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();

            prevX = cx;
            prevY = cy;
        });
        // Final line to right
        ctx.beginPath(); ctx.moveTo(prevX, prevY); ctx.lineTo(w-50, prevY); ctx.stroke();
    }


    // ==========================================
    // MODULE 2: CONTINUOUS (MONTE CARLO)
    // ==========================================
    let mcPoints = []; // {x, y, hit}
    const fn = (x) => (1/9) * x * x; // PDF

    function runMonteCarlo() {
        const rangeA = parseFloat(document.getElementById('rangeA').value);
        const rangeB = parseFloat(document.getElementById('rangeB').value);
        
        for(let i=0; i<1000; i++) {
            // Random point in bounding box [0,3] x [0,1]
            // Max value of f(x) on [0,3] is f(3) = 1.
            const px = Math.random() * 3;
            const py = Math.random() * 1;
            
            // Is it under curve?
            const underCurve = py <= fn(px);
            // Is it in range?
            const inRange = px >= rangeA && px <= rangeB;
            
            // For coloring: 
            // - Under curve AND in range = HIT (Green)
            // - Under curve but NOT in range = VALID PDF AREA (Blue)
            // - Above curve = MISS (Gray/Red)
            
            let status = 'miss';
            if(underCurve) {
                status = inRange ? 'hit' : 'pdf';
            }
            
            mcPoints.push({x: px, y: py, status: status});
        }
        updateMCStats(rangeA, rangeB);
        drawContinuous();
    }

    function resetMonteCarlo() {
        mcPoints = [];
        updateMCStats(0,0);
        drawContinuous();
    }

    function updateMCStats(a, b) {
        const total = mcPoints.length;
        if(total === 0) {
            document.getElementById('mcTotal').textContent = 0;
            document.getElementById('mcHits').textContent = 0;
            document.getElementById('mcProb').textContent = "0.000";
            document.getElementById('mcTheory').textContent = "0.000";
            return;
        }

        // Count points under curve (total PDF area approximation)
        const pdfPoints = mcPoints.filter(p => p.status === 'hit' || p.status === 'pdf').length;
        const hitPoints = mcPoints.filter(p => p.status === 'hit').length;

        // Est Prob = Hits / Total PDF Points (since Area of PDF = 1)
        // Wait, standard MC Integration: Area = (Hits / TotalThrown) * BoundingBoxArea
        // Box Area = 3 * 1 = 3.
        // Integral(f) from 0 to 3 is 1.
        // So approx integral in range = (Hits in Range / Total Thrown) * 3
        
        const estProb = (hitPoints / total) * 3;

        // Theory: Integral x^2/9 = [x^3/27] from a to b
        const theory = (Math.pow(b, 3)/27) - (Math.pow(a, 3)/27);

        document.getElementById('mcTotal').textContent = total;
        document.getElementById('mcHits').textContent = hitPoints;
        document.getElementById('mcProb').textContent = estProb.toFixed(4);
        document.getElementById('mcTheory').textContent = theory.toFixed(4);
    }

    function drawContinuous() {
        const canvas = document.getElementById('contCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const t = translations[currentLang];

        ctx.clearRect(0,0,w,h);

        const rangeA = parseFloat(document.getElementById('rangeA').value);
        const rangeB = parseFloat(document.getElementById('rangeB').value);

        // Scales: X [0,3] -> W, Y [0,1.2] -> H
        const pad = 40;
        const scaleX = (w - 2*pad) / 3;
        const scaleY = (h - 2*pad) / 1.2; 
        const originX = pad;
        const originY = h - pad;

        const toScreen = (x, y) => ({
            x: originX + x * scaleX,
            y: originY - y * scaleY
        });

        // Draw Axes
        ctx.strokeStyle = "#4b5563";
        ctx.beginPath();
        ctx.moveTo(originX, originY); ctx.lineTo(originX + 3*scaleX, originY);
        ctx.moveTo(originX, originY); ctx.lineTo(originX, originY - 1.2*scaleY);
        ctx.stroke();

        // Label Axes
        ctx.fillStyle = "#fff";
        ctx.fillText("0", originX, originY + 15);
        ctx.fillText("3", originX + 3*scaleX, originY + 15);
        ctx.fillText("1", originX - 15, originY - 1*scaleY);
        ctx.fillText(t.labelDensity, originX + 10, 20);

        // Draw Function Curve
        ctx.beginPath();
        ctx.strokeStyle = "#3b82f6";
        ctx.lineWidth = 2;
        for(let x=0; x<=3; x+=0.05) {
            const p = toScreen(x, fn(x));
            if(x===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // Draw Selection Range (Background)
        const pA = toScreen(rangeA, 0).x;
        const pB = toScreen(rangeB, 0).x;
        ctx.fillStyle = "rgba(16, 185, 129, 0.1)";
        ctx.fillRect(pA, 20, pB - pA, h - 20 - pad);

        // Draw Points
        mcPoints.forEach(p => {
            const sp = toScreen(p.x, p.y);
            if(p.status === 'hit') ctx.fillStyle = "#10b981"; // Green
            else if(p.status === 'pdf') ctx.fillStyle = "#3b82f6"; // Blue (valid but out of range)
            else ctx.fillStyle = "rgba(75, 85, 99, 0.3)"; // Miss (Gray)
            
            ctx.beginPath(); ctx.arc(sp.x, sp.y, 1.5, 0, Math.PI*2); ctx.fill();
        });
    }

    // ==========================================
    // MODULE 3: 2D VARIABLES
    // ==========================================
    let mode2d = 'joint'; // joint, marginal, condX0
    // Data from Task 6
    // Rows: X=0, X=1
    // Cols: Y=1, Y=2, Y=3
    const dist2D = [
        [0.10, 0.15, 0.05], // X=0
        [0.20, 0.30, 0.20]  // X=1
    ];
    let animProgress = 0;
    let animId2d = null;

    function set2DMode(m) {
        mode2d = m;
        animProgress = 0;
        if(animId2d) cancelAnimationFrame(animId2d);
        animate2D();
    }

    function animate2D() {
        // Simple linear progress 0 -> 1
        animProgress += 0.02;
        if(animProgress > 1) animProgress = 1;
        
        draw2D();
        
        if(animProgress < 1) {
            animId2d = requestAnimationFrame(animate2D);
        }
    }

    function draw2D() {
        const canvas = document.getElementById('canvas2d');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const t = translations[currentLang];
        
        ctx.clearRect(0,0,w,h);

        // Grid setup
        const rows = 2;
        const cols = 3;
        const cellW = 80;
        const cellH = 60;
        const startX = 150;
        const startY = 100;
        const gap = 10;

        // Ease function
        const ease = animProgress * (2 - animProgress); // easeOutQuad

        // Draw Headers
        ctx.fillStyle = "#fff";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center";
        
        // Y Labels (Cols)
        [1, 2, 3].forEach((y, i) => {
            ctx.fillText(`Y=${y}`, startX + i*(cellW+gap) + cellW/2, startY - 20);
        });
        // X Labels (Rows)
        [0, 1].forEach((x, i) => {
            ctx.fillText(`X=${x}`, startX - 40, startY + i*(cellH+gap) + cellH/2 + 5);
        });

        // 1. JOINT MODE / MARGINAL MODE BASE
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                let val = dist2D[r][c];
                let opacity = 0.2 + val * 2; // naive heatmap scaling
                
                let dx = 0;
                let dy = 0;
                let label = val.toFixed(2);
                let color = `rgba(59, 130, 246, ${opacity})`; // Blue
                let textColor = "#fff";

                if(mode2d === 'marginal') {
                    // Split the block visually? Or simply move copies?
                    // Let's simplify: In marginal mode, we draw GHOSTS at original pos,
                    // and move colored blocks to edges.
                    
                    // Draw ghost
                    ctx.fillStyle = "rgba(255,255,255,0.05)";
                    ctx.fillRect(startX + c*(cellW+gap), startY + r*(cellH+gap), cellW, cellH);
                    
                    // Animate to Marginal X (Right side)
                    // We sum rows. So blocks from (r,0), (r,1), (r,2) move to (r, 3-idx)
                    // Actually, let's just create summation bars at right/bottom
                    
                    // Instead of moving individual cells, let's fade out joint cells and fade in marginal bars
                } 
                else if(mode2d === 'condX0') {
                    if(r === 1) {
                        opacity = 0.1 * (1 - ease); // Fade out row 1
                        textColor = `rgba(255,255,255,${1-ease})`;
                    } else {
                        // Row 0 scales up
                        // Sum is 0.3. New values: 0.1/0.3, 0.15/0.3, 0.05/0.3
                        // 0.33, 0.5, 0.16
                        const condVal = val / 0.3;
                        // Interpolate text
                        if(ease > 0.5) label = condVal.toFixed(2);
                        
                        // Highlight color change blue -> green
                        // We can't easily animate hex/rgba in vanilla without logic, so let's stick to blue but brighter
                        color = `rgba(16, 185, 129, ${0.2 + condVal})`;
                    }
                }

                if(mode2d !== 'marginal') {
                    ctx.fillStyle = color;
                    ctx.fillRect(startX + c*(cellW+gap), startY + r*(cellH+gap), cellW, cellH);
                    ctx.fillStyle = textColor;
                    ctx.fillText(label, startX + c*(cellW+gap) + cellW/2, startY + r*(cellH+gap) + cellH/2 + 5);
                }
            }
        }

        if(mode2d === 'marginal') {
            const p = ease;

            // Show Joint faded
            ctx.globalAlpha = 1 - p;
            // (Re-draw simple grid for context)
            for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) {
                 ctx.fillStyle = "#3b82f6"; ctx.fillRect(startX + c*(cellW+gap), startY + r*(cellH+gap), cellW, cellH);
                 ctx.fillStyle = "#fff"; ctx.fillText(dist2D[r][c], startX + c*(cellW+gap) + cellW/2, startY + r*(cellH+gap) + cellH/2);
            }
            ctx.globalAlpha = 1;

            // DRAW MARGINAL X (Sum Rows) -> Right Side
            const mX = [0.30, 0.70];
            const mXPos = startX + 3*(cellW+gap) + 20;
            
            ctx.fillStyle = "#f59e0b"; // Orange
            ctx.fillText(t.labelMarginalX, mXPos + 40, startY - 20);
            
            mX.forEach((val, r) => {
                // Animate width growth
                const wBar = 100 * val * p;
                ctx.fillStyle = `rgba(245, 158, 11, ${p})`;
                ctx.fillRect(mXPos, startY + r*(cellH+gap), wBar, cellH);
                if(p > 0.8) {
                    ctx.fillStyle = "#fff";
                    ctx.fillText(val.toFixed(2), mXPos + wBar + 20, startY + r*(cellH+gap) + cellH/2);
                }
            });

            // DRAW MARGINAL Y (Sum Cols) -> Bottom
            const mY = [0.30, 0.45, 0.25];
            const mYPos = startY + 2*(cellH+gap) + 20;

            ctx.fillStyle = "#8b5cf6"; // Purple
            ctx.fillText(t.labelMarginalY, startX - 60, mYPos + 40);

            mY.forEach((val, c) => {
                const hBar = 100 * val * p;
                ctx.fillStyle = `rgba(139, 92, 246, ${p})`;
                ctx.fillRect(startX + c*(cellW+gap), mYPos, cellW, hBar);
                if(p > 0.8) {
                    ctx.fillStyle = "#fff";
                    ctx.fillText(val.toFixed(2), startX + c*(cellW+gap) + cellW/2, mYPos + hBar + 15);
                }
            });
        }
    }

    // Init defaults
    setLanguage('en');

</script>

</body>
</html>